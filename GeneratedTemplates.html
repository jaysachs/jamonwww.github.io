<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- svn-version: ${svn.version} -->
<html>
  <head>
    <title>Jamon Generated Templates</title>
    <meta name="keywords" content="template,templates,typed,dynamic,text,java,MVC,render,model-view-controller,typesafety,typesafe"></meta>
    <link rel="SHORTCUT ICON" href="/favicon.ico">
    <link rel="StyleSheet" href="base.css" type="text/css" media="screen" />
  </head>

  <body>

    <div id="logo">
      <h1 id="logo1">Jamon</h1>
      <h3 id="logo2">a typed template engine for Java</h3>
    </div>

    <h3 id="tagline">
      <span class="tagline1">type</span> <span class="tagline2">safe</span> <span class="tagline3">templating</span><br />
    </h3>

    <div class="header" id="header1"><span /></div>
    <div class="header" id="header2"><span /></div>
    <div class="header" id="header3"><span /></div>
    <div class="header" id="header4"><span /></div>

    <div id="nav">
      <ul class="nav">
          <li class="nav"
    >
<a href="index.html" >Home</a>
</li>

          <li class="nav"
    >
<a href="Features.html" >Features</a>
</li>

          <li class="nav"
    >
<a href="News.html" >News</a>
</li>

          <li class="nav"
    >
<a href="Download.html" >Download</a>
</li>

          <li class="nav"
    >
<a href="Contact.html" >Contact</a>
</li>

          <li class="nav"
    >
<a href="About.html" >About</a>
</li>

        </ul>

        <ul class="nav">
          <li class="static">Documentation</li>
          <li class="nav"
    >
<a href="Overview.html" >Overview</a>
</li>

          <li class="nav"
    >
<a href="tutorial/TutorialPath.html" >Tutorial</a>
</li>

          <li class="nav"
    id="current">
<a href="GeneratedTemplates.html" >Generated classes</a>
</li>

          <li class="nav"
    >
<a href="UserGuide.html" >User's Guide</a>
</li>

          <li class="nav"
    >
<a href="Ant.html" >Ant integration</a>
</li>

          <li class="nav"
    >
<a href="Maven.html" >Maven integration</a>
</li>

          <li class="nav"
    >
<a href="Eclipse.html" >Eclipse plugin</a>
</li>

          <li class="nav"
    >
<a href="Servlets.html" >Servlet usage</a>
</li>

          <li class="nav"
    >
<a href="Reference.html" >Reference manual</a>
</li>

          <li class="nav">
           <a href='javadoc/index.html'>Javadoc</a>
          </li>
        </ul>
      </div>
      <div id="main">
        <h2>Generated Template Classes</h2>

Jamon templates are translated into Java classes, either by using the
<a href="JamonTask.html">Jamon ant task</a>, or by executing the
<a href="javadoc/org/jamon/TemplateProcessor.html">TemplateProcessor</a>
class. These generated classes have the following relationships to the
template sources:
<ul>
  <li>
    The class name is the same as the name of the template source file
    excluding any filename extension (i.e. a suffix starting with
    '.').
  </li>
  <li>
    The package of the class maps directly to the directory path from
    the template source directory to the template.
  </li>
  <li>
    The generated class has a <code>render</code> method whose
    arguments are a writer, followed by the required arguments
    declared in the template. The order of declaration in the
    <code>render</code> method is the same as the order of declaration
    in the template.
  </li>
  <li>
    The generated class has a <code>makeRenderer</code> method taking
    the same parameters as <code>render</code>, except for the writer.
  <li>
    Optional arguments in the template
    generate <code>setXXX</code> methods in the class.
  </li>
  <li>
    If a value for the <code>org.jamon.contextType</code> property has been set via
    <a href="Reference.html#jamonProperties"><code>jamon.properties</code></a>
    then there is a <code>setJamonContext</code> method in the class.
  </li>
</ul>

For example, suppose there is a template <code>MyTemplate</code> in the
directory <code>tmpls/org/foo</code>, the template source directory is
set to <code>tmpls</code>, and <code>MyTemplate</code> contains the
declarations

<pre class="jamon">&lt;%args&gt;
  int i;
  String s = "yes";
  java.math.BigDecimal someNumber = null;
  boolean b;
&lt;/%args&gt;</pre>

Suppose further that in <code>tmpls</code> is a <code>jamon.properties</code> file containing
<pre class="properties">
org.jamon.contextType=org.foo.MyContext
</pre>

Then a simplified sketch (showing only the pertinent public methods) of the
generated class would be:

<pre class="java">  package org.foo;

  import org.jamon.TemplateManager;
  import org.jamon.escaping.Escaping;

  public class MyTemplate
    extends org.jamon.AbstractTemplateProxy
  {
    public MyTemplate() { ... }
    public MyTemplate(TemplateManager manager) { ... }

    public void render(int i, boolean b)
      throws java.io.IOException { ... }

    public Renderer makeRenderer(java.io.Writer writer, int i, boolean b)
      throws java.io.IOException { ... }

    public MyTemplate setS(String s) { ... }

    public MyTemplate setSomeNumber(java.math.BigDecimal someNumber) { ... }

    public MyTemplate setJamonContext(org.foo.MyContext jamonContext() { ... }
  }</pre>

If one template inherits from another, then:
<ul>
  <li>
    The generated class of the parent template will be abstract, and
    will not have <code>render</code> or <code>makeRenderer</code>
    methods.
  </li>

  <li>
    The generated class of the child template will extend the
    generated class of the parent template.
  </li>

  <li>
    Any setter methods for optional arguments declared in the parent
    template will be declared to return the generated class for the
    parent, not the child.
  </li>

  <li>
    The generated class for the parent template will define a public
    abstract inner class named <code>ParentRenderer</code>, which will
    have:

    <ul>
      <li>
        A render method taking a writer, followed by the required
        arguments for the parent template (including any required
        arguments for the parent template's ancestors, if any).
      </li>

      <li>
        <code>setXXX</code> methods for each of the parent template's
        optional arguments (including any optional arguments for the
        parent template's ancestors, if any).
      </li>

      <li>
        If a <a href="Reference.html#jamonProperties"><code>jamon.properties</code></a>
        file has declared a value for <code>org.jamon.contextType</code>, then there will be a
        <code>setJamonContext</code> method.
      </li>

      <li>
        If the parent template itself extends another template (which
        we'll call the grandparent template), a
        <code>makeParentRender</code> method taking as arguments the
        required arguments declared by the parent template, and
        returning an object whose type is the inner
        <code>ParentRenderer</code> class of the grandparent
        template's generated class.
      </li>
    </ul>
  </li>

  <li>
    If the child template is a final template (i.e. does not contain a
    <code>&lt;&amp; *CHILD &amp;&gt;</code> call), then its generated
    class will contain a <code>makeParentRenderer</code> method which
    takes as arguments the required arguments declared by the child
    template, and returns an object whose type is the inner
    <code>ParentRenderer</code> class of the parent template's generated class.
  </li>
</ul>

For example, if <code>/org/foo/ParentTemplate</code> contained the
declarations

<pre class="jamon">&lt;%args&gt;
  int i;
  String s = "yes";
  Integer count;
&lt;/%args&gt;</pre>

then the generated class <code>org.foo.ParentTemplate</code> would look
something like:

<pre class="java">  package org.foo;

  import org.jamon.escaping.Escaping;

  public abstract class ParentTemplate
    extends org.jamon.AbstractTemplateProxy
  {
    public ParentTemplate setS(String s) { ... }

    public abstract class ParentRenderer
    {
      public ParentRenderer setS(String s) { ... }

      public ParentRenderer setJamonContext(org.foo.MyContext jamonContext) { ... }

      public void render(java.io.Writer writer, int i, Integer count)
        throws java.io.IOException { ... }
    }
  }</pre>

Moreover, if <code>/org/foo/ChildTemplate</code> contained the
declarations

<pre class="jamon"
>&lt;%extends ParentTemplate&gt;
&lt;%args&gt;
  long t;
  java.math.BigDecimal amount = new BigDecimal(0);
  double x;
&lt;/%args&gt;</pre>

then the generated class <code>org.foo.ChildTemplate</code> would look
something like:

<pre class="java">  package org.foo;

  import org.jamon.TemplateManager;
  import org.jamon.escaping.Escaping;

  public abstract class ChildTemplate
    extends org.foo.ParentTemplate
  {
    public ChildTemplate() { ... }
    public ChildTemplate(TemplateManager manager) { ... }

    public void render(java.io.Writer writer, int i, Integer count, long t, double x)
      throws java.io.IOException { ... }

    public Renderer makeRenderer(int i, Integer count, long t, double x)
      throws java.io.IOException { ... }

    public ChildTemplate setAmount(java.math.BigDecimal amount) { ... }

    public ChildTemplate setJamonContext(org.foo.MyContext jamonContext) { ... }

    public ParentTemplate.ParentRenderer makeParentRenderer(long t, double x)
      throws java.io.IOException { ... }
  }</pre>

An instantiated template may be used at most once.

      </div>

    <div id="logo">
    <h1 id="logo1">Jamon</h1>
    <h3 id="logo2">a typed template engine for Java</h3>
    </div>


  </body>
</html>

